
### Triage and Remediation
<Tabs>


<Tab title='Prevention'>
### How to Prevent
<AccordionGroup>
<Accordion title='Using Console' defaultOpen='true'>
To prevent secrets in container environment variables in Kubernetes using the AWS console, follow these steps:

1. **Use AWS Secrets Manager or AWS Systems Manager Parameter Store:**
   - Navigate to the AWS Management Console.
   - Go to the AWS Secrets Manager or AWS Systems Manager Parameter Store.
   - Store your sensitive information (secrets) in these services instead of hardcoding them in environment variables.

2. **Configure IAM Roles for Service Accounts (IRSA):**
   - Go to the IAM section in the AWS Management Console.
   - Create an IAM role with the necessary permissions to access the secrets stored in AWS Secrets Manager or Parameter Store.
   - Attach this IAM role to the Kubernetes service account that your pods are using.

3. **Modify Kubernetes Deployment Manifests:**
   - Instead of specifying secrets directly in the environment variables, modify your Kubernetes deployment manifests to use the secrets from AWS Secrets Manager or Parameter Store.
   - Use the `aws-sdk` or other relevant libraries within your application code to fetch the secrets at runtime.

4. **Enable Encryption for Kubernetes Secrets:**
   - Navigate to the Amazon EKS section in the AWS Management Console.
   - Enable envelope encryption for Kubernetes secrets using AWS KMS (Key Management Service).
   - This ensures that any secrets stored in Kubernetes are encrypted at rest.

By following these steps, you can prevent the exposure of sensitive information in container environment variables and enhance the security of your Kubernetes deployments on AWS.
</Accordion>

<Accordion title='Using CLI'>
To prevent secrets in container environment variables in Kubernetes using AWS CLI, you can follow these steps:

1. **Create a Kubernetes Secret:**
   Instead of embedding secrets directly in environment variables, store them securely in Kubernetes Secrets. Use the following command to create a secret in Kubernetes:

   ```sh
   kubectl create secret generic my-secret --from-literal=username=myuser --from-literal=password=mypassword
   ```

2. **Update IAM Policies:**
   Ensure that your IAM roles and policies are configured to allow access to the necessary secrets. Use the AWS CLI to attach the appropriate policy to your IAM role:

   ```sh
   aws iam attach-role-policy --role-name my-role --policy-arn arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
   ```

3. **Configure Kubernetes Deployment to Use Secrets:**
   Modify your Kubernetes deployment YAML file to reference the secret instead of hardcoding it in environment variables. Here is an example snippet:

   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: my-deployment
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: my-app
     template:
       metadata:
         labels:
           app: my-app
       spec:
         containers:
         - name: my-container
           image: my-image
           env:
           - name: USERNAME
             valueFrom:
               secretKeyRef:
                 name: my-secret
                 key: username
           - name: PASSWORD
             valueFrom:
               secretKeyRef:
                 name: my-secret
                 key: password
   ```

4. **Apply the Updated Deployment:**
   Use the `kubectl` command to apply the updated deployment configuration:

   ```sh
   kubectl apply -f my-deployment.yaml
   ```

By following these steps, you ensure that sensitive information is stored securely in Kubernetes Secrets and not exposed directly in environment variables.
</Accordion>

<Accordion title='Using Python'>
Preventing secrets in container environment variables in Kubernetes is crucial for maintaining security. Here are four steps to prevent this misconfiguration using Python scripts:

### 1. **Validate Kubernetes Manifests Before Deployment**

Create a Python script to validate Kubernetes manifests and ensure that secrets are not included in environment variables.

```python
import yaml
import sys

def validate_manifest(file_path):
    with open(file_path, 'r') as file:
        documents = yaml.safe_load_all(file)
        for doc in documents:
            if 'kind' in doc and doc['kind'] == 'Pod':
                for container in doc['spec']['containers']:
                    if 'env' in container:
                        for env in container['env']:
                            if 'value' in env and 'secret' in env['value']:
                                print(f"Error: Secret found in environment variables in container {container['name']}")
                                sys.exit(1)
    print("Validation passed: No secrets in environment variables.")

# Example usage
validate_manifest('path_to_your_k8s_manifest.yaml')
```

### 2. **Use Kubernetes Admission Controllers**

Implement a Python-based admission controller webhook to intercept and validate pod creation requests.

```python
from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/validate', methods=['POST'])
def validate():
    request_info = request.get_json()
    pod_spec = request_info['request']['object']['spec']
    for container in pod_spec['containers']:
        if 'env' in container:
            for env in container['env']:
                if 'value' in env and 'secret' in env['value']:
                    return jsonify({
                        "response": {
                            "allowed": False,
                            "status": {
                                "message": f"Secret found in environment variables in container {container['name']}"
                            }
                        }
                    })
    return jsonify({"response": {"allowed": True}})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=443, ssl_context=('path_to_cert.pem', 'path_to_key.pem'))
```

### 3. **Automate Scanning with CI/CD Pipeline**

Integrate a Python script in your CI/CD pipeline to scan Kubernetes manifests for secrets before deployment.

```python
import os
import yaml

def scan_manifests(directory):
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.yaml') or file.endswith('.yml'):
                file_path = os.path.join(root, file)
                validate_manifest(file_path)

def validate_manifest(file_path):
    with open(file_path, 'r') as file:
        documents = yaml.safe_load_all(file)
        for doc in documents:
            if 'kind' in doc and doc['kind'] == 'Pod':
                for container in doc['spec']['containers']:
                    if 'env' in container:
                        for env in container['env']:
                            if 'value' in env and 'secret' in env['value']:
                                print(f"Error: Secret found in environment variables in container {container['name']} in file {file_path}")
                                return False
    return True

# Example usage
if not scan_manifests('path_to_your_k8s_manifests_directory'):
    print("Validation failed: Secrets found in environment variables.")
    sys.exit(1)
else:
    print("Validation passed: No secrets in environment variables.")
```

### 4. **Enforce Policies with Open Policy Agent (OPA)**

Use OPA with a Python script to define and enforce policies that prevent secrets in environment variables.

```python
import requests
import json

def enforce_policy(manifest):
    opa_url = "http://localhost:8181/v1/data/kubernetes/admission"
    headers = {"Content-Type": "application/json"}
    data = {
        "input": {
            "review": {
                "object": manifest
            }
        }
    }
    response = requests.post(opa_url, headers=headers, data=json.dumps(data))
    result = response.json()
    if not result['result']['allow']:
        print(f"Policy violation: {result['result']['reason']}")
        return False
    return True

# Example usage
with open('path_to_your_k8s_manifest.yaml', 'r') as file:
    manifest = yaml.safe_load(file)
    if not enforce_policy(manifest):
        print("Validation failed: Policy violation.")
        sys.exit(1)
    else:
        print("Validation passed: No policy violations.")
```

These steps and scripts will help you prevent secrets from being included in container environment variables in Kubernetes, enhancing the security of your deployments.
</Accordion>

</AccordionGroup>
</Tab>
<Tab title='Cause'>
### Check Cause
<AccordionGroup>
<Accordion title='Using Console' defaultOpen='true'>
1. Log in to the AWS Management Console and navigate to the Amazon Elastic Kubernetes Service (EKS).
2. Select the cluster where your Kubernetes application is running.
3. Navigate to the "Workloads" section and select the specific workload (Deployment, StatefulSet, DaemonSet, etc.) that you want to inspect.
4. In the workload details, navigate to the "Environment Variables" section. Here, you can see all the environment variables that are set for the containers in the workload. If there are any secrets or sensitive information stored in these environment variables, it indicates a misconfiguration.
</Accordion>

<Accordion title='Using CLI'>
1. First, you need to install and configure AWS CLI. You can do this by following the instructions provided by AWS. Make sure you have the necessary permissions to access the Kubernetes services.

2. Once you have AWS CLI installed and configured, you can use the following command to list all the Kubernetes services in your AWS account:

   ```
   aws eks list-clusters
   ```

   This command will return a list of all the Kubernetes clusters in your AWS account.

3. After identifying the cluster you want to inspect, you can use the following command to describe the cluster:

   ```
   aws eks describe-cluster --name <cluster-name>
   ```

   Replace `<cluster-name>` with the name of the cluster you want to inspect. This command will return a detailed description of the cluster, including the environment variables for each container.

4. To specifically check for secrets in the environment variables, you can use the following command:

   ```
   aws eks describe-cluster --name <cluster-name> | grep -i 'env'
   ```

   This command will return a list of all the environment variables for each container in the cluster. You can then manually inspect this list for any secrets. Note that this method is not foolproof, as secrets may not always be clearly identifiable.
</Accordion>

<Accordion title='Using Python'>
1. **Import Required Libraries**: The first step is to import the required libraries in your Python script. You will need the Kubernetes client library to interact with the Kubernetes API.

    ```python
    import os
    from kubernetes import client, config
    ```

2. **Configure Kubernetes Client**: The next step is to configure the Kubernetes client to interact with your Kubernetes cluster. You can do this by loading the kubeconfig file which contains the credentials and connection details of your Kubernetes cluster.

    ```python
    config.load_kube_config()
    v1 = client.CoreV1Api()
    ```

3. **List All Pods**: Now, you can list all the pods in your Kubernetes cluster. You can do this by calling the `list_pod_for_all_namespaces` method of the `CoreV1Api` object.

    ```python
    pods = v1.list_pod_for_all_namespaces(watch=False)
    ```

4. **Check for Secrets in Environment Variables**: Finally, you can iterate over all the pods and their containers to check if they have any secrets in their environment variables. You can do this by accessing the `env` attribute of the `container` object.

    ```python
    for i in pods.items:
        for j in i.spec.containers:
            if j.env is not None:
                for k in j.env:
                    if 'secret' in k.name.lower():
                        print("Pod {} in namespace {} has a secret in environment variable: {}".format(i.metadata.name, i.metadata.namespace, k.name))
    ```
This script will print the names of all pods and their namespaces that have secrets in their environment variables.
</Accordion>

</AccordionGroup>
</Tab>
<Tab title='Remediation'>
### Remediation

<AccordionGroup>
<Accordion title='Using Console' defaultOpen='true'>
To remediate secrets being exposed in container environment variables in AWS Kubernetes using the AWS console, follow these steps:

1. **Identify the exposed secrets**: First, identify which secrets are being exposed in the container environment variables. You can do this by examining the Kubernetes deployment configuration or inspecting the running pods.

2. **Store secrets securely**: AWS provides a service called AWS Secrets Manager that allows you to store, retrieve, and manage sensitive data such as passwords, API keys, and other secrets. Store the secrets in AWS Secrets Manager instead of hardcoding them in the container environment variables.

3. **Update Kubernetes deployment configuration**:
   - Open the AWS Management Console and navigate to the Amazon EKS console.
   - Select your EKS cluster and navigate to the "Workloads" section.
   - Find the deployment that contains the exposed secrets and click on it to view the details.
   - Update the deployment configuration to fetch the secrets from AWS Secrets Manager instead of using them directly as environment variables.

4. **Use AWS IAM roles for service accounts**: Instead of directly accessing AWS Secrets Manager from your application code, you can use IAM roles for service accounts (IRSA) to securely provide AWS permissions to your Kubernetes pods. This way, your pods can access AWS services securely without needing to store AWS credentials or secrets in the container environment variables.

5. **Monitor and audit**: Regularly monitor and audit your Kubernetes clusters for any exposed secrets or misconfigurations. Set up alerts and notifications to detect any unauthorized access or changes to your secrets.

By following these steps, you can remediate secrets being exposed in container environment variables in AWS Kubernetes and ensure that your sensitive data is stored and accessed securely.

#
</Accordion>

<Accordion title='Using CLI'>
To remediate the issue of storing secrets in container environment variables in AWS Kubernetes using AWS CLI, follow these steps:

1. **Create a Secret in AWS Secrets Manager**:
   - Use the AWS CLI to create a secret in AWS Secrets Manager that will store the sensitive information securely. For example, you can create a secret named `my-secret` with key-value pairs for your sensitive data.

   ```bash
   aws secretsmanager create-secret --name my-secret --secret-string '{"username":"my_username", "password":"my_password"}'
   ```

2. **Update Kubernetes Deployment YAML**:
   - Modify your Kubernetes deployment YAML file to reference the secret stored in AWS Secrets Manager. Replace the environment variables containing sensitive data with references to the secret.

   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: my-deployment
   spec:
     template:
       spec:
         containers:
         - name: my-container
           image: my-image
           env:
           - name: USERNAME
             valueFrom:
               secretKeyRef:
                 name: my-secret
                 key: username
           - name: PASSWORD
             valueFrom:
               secretKeyRef:
                 name: my-secret
                 key: password
   ```

3. **Apply the Changes**:
   - Apply the updated deployment YAML file to your Kubernetes cluster using kubectl.

   ```bash
   kubectl apply -f deployment.yaml
   ```

4. **Verify the Deployment**:
   - Verify that the deployment has been updated successfully and the sensitive data is now being sourced from the AWS Secrets Manager secret.

   ```bash
   kubectl get pods
   kubectl describe pod <pod_name>
   ```

By following these steps, you can remediate the issue of storing secrets in container environment variables in AWS Kubernetes by securely storing sensitive information in AWS Secrets Manager and referencing them in your Kubernetes deployment configuration.
</Accordion>

<Accordion title='Using Python'>
To remediate the issue of storing secrets in container environment variables in AWS Kubernetes using Python, you can follow these steps:

1. **Store Secrets in AWS Secrets Manager**:
   - Store your sensitive information such as API keys, passwords, etc., securely in AWS Secrets Manager.

2. **Grant Access to Secrets**:
   - Ensure that the Kubernetes service account has the necessary permissions to access the secrets stored in AWS Secrets Manager.

3. **Install AWS SDK for Python (Boto3)**:
   - Install the Boto3 library in your Python environment by running the following command:
     ```
     pip install boto3
     ```

4. **Retrieve Secrets in Python**:
   - Write a Python script to retrieve the secrets from AWS Secrets Manager. Here is an example script:
     ```python
     import boto3

     def get_secret(secret_name):
         client = boto3.client('secretsmanager')
         response = client.get_secret_value(SecretId=secret_name)
         secret = response['SecretString']
         return secret

     # Example usage
     secret_value = get_secret('your_secret_name')
     ```

5. **Inject Secrets into Kubernetes Pods**:
   - Use Kubernetes Secrets to inject the retrieved secrets into your application pods. You can create a Kubernetes Secret object using the retrieved secret value in your Python script.

6. **Update Kubernetes Deployment**:
   - Update your Kubernetes Deployment manifest to mount the secret as a volume or set it as an environment variable in your application container.

7. **Deploy the Updated Application**:
   - Deploy the updated application to your AWS EKS cluster using kubectl or any other deployment tool.

By following these steps, you can remediate the issue of storing secrets in container environment variables in AWS Kubernetes using Python and securely manage your application's sensitive information.
</Accordion>

</AccordionGroup>
</Tab>
</Tabs>
